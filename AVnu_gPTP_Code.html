<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.9" />
<title>AVnu gPTP Code</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install(2);
/*]]>*/
</script>
</head>
<body class="article" style="max-width:55em">
<div id="header">
<h1>AVnu gPTP Code</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div id="toc">
  <div id="toctitle">Table of Contents</div>
  <noscript><p><b>JavaScript must be enabled in your browser to display the table of contents.</b></p></noscript>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction">Introduction</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="conventions">Conventions</h3>
<div class="paragraph"><p>Text in red denotes information that is correct at the time the document
of writing, but is likely to change</p></div>
<div class="paragraph"><p>All CAPS text denotes constants or enumerations taken from the OpenAVB
gPTP code</p></div>
</div>
<div class="sect2">
<h3 id="abbreviation-definitions">Abbreviation Definitions</h3>
<div class="paragraph"><p>GM – Grandmaster. The clock that serves as master for the network</p></div>
<div class="paragraph"><p>BMCA – best master clock algorithm</p></div>
</div>
<div class="sect2">
<h3 id="references">References</h3>
<div class="paragraph"><p><strong>[1]</strong> IEEE 802.1AS-2011: Timing and Synchronization for Time-Sensitive
Applications in Bridged Local Area Networks</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="common-code">Common Code</h2>
<div class="sectionbody">
<div class="paragraph"><p>Top level code three components clock, port, message, handling</p></div>
<div class="sect2">
<h3 id="clock-ieee1588clock-class-in-avbts_clock.hppieee1588clock.cpp">Clock (IEEE1588Clock class in avbts_clock.hpp/ieee1588clock.cpp)</h3>
<div class="paragraph"><p>The IEEE1588Clock class is a container for timing functions and state
that is global across all ports.</p></div>
<div class="sect3">
<h4 id="timers">Timers</h4>
<div class="paragraph"><p>The timers API is part of the Clock class and is used to deliver events
to deliver events to Port objects. The event types are:</p></div>
<div class="ulist"><ul>
<li>
<p>
STATE_CHANGE_EVENT – causes BMCA algorithm to run<br />
This event is scheduled when Announce message is received
(ptp_message.cpp line 775)<br />
This event is handled in code lines 433-540 in ieee1588port.cpp
</p>
</li>
<li>
<p>
SYNC_INTERVAL_TIMEOUT_EXPIRES
</p>
<div class="paragraph"><p>When a port object is in PTP_MASTER mode, this event is delivered once
per sync interval (see [1] clause 11.2)</p></div>
<div class="paragraph"><p>This event is handled in code lines 715-844 in ieee1588port.cpp
* PDELAY_INTERVAL_TIMEOUT_EXPIRES</p></div>
<div class="paragraph"><p>This event is delivered once per pdelay interval (see [1] clause 11.2)</p></div>
<div class="paragraph"><p>This event is handled in code lines 612-714 in ieee1588port.cpp
* ANNOUNCE_INTERVAL_TIMEOUT_EXPIRES</p></div>
<div class="paragraph"><p>When a port object is in PTP_MASTER mode, this event is delivered once
per announce interval (see [1] clause 10.2)</p></div>
<div class="paragraph"><p>This event is handled in code lines 845-862 in ieee1588port.cpp
* SYNC_RECEIPT_TIMEOUT_EXPIRES</p></div>
<div class="paragraph"><p>This event is delivered if a sync message is not received before the
sync receipt timeout occurs (see [1] clause 10.6.3.1)</p></div>
<div class="paragraph"><p>This event is handled in code lines 541-611 in ieee1588port.cpp
* ANNOUNCE_RECEIPT_TIMEOUT_EXPIRES</p></div>
<div class="paragraph"><p>This event is delivered if a sync message is not received before the
sync receipt timeout occurs (see [1] clause 10.6.3.1)</p></div>
<div class="paragraph"><p>This event is handled in code lines 541-611 in ieee1588port.cpp
* PDELAY_DEFERRED_PROCESSING</p></div>
<div class="paragraph"><p>This event is scheduled (code line 1390 in ptp_message.cpp) when a
pdelay response followup message is received and the corresponding
pdelay request timestamp is not complete (PDELAY_PENDING_TIMESTAMP)</p></div>
<div class="paragraph"><p>This event is handled in code lines 866-878 in ieee1588port.cpp
* PDELAY_RESP_RECEIPT_TIMEOUT_EXPIRES</p></div>
<div class="paragraph"><p>This event is delivered if a pdelay response is not received within the
timeout interval</p></div>
<div class="paragraph"><p>This event is handled in code lines 879-882 in ieee1588port.cpp
* POWERUP – duplicate of INITIALIZE event
* INITIALIZE</p></div>
<div class="paragraph"><p>This event causes the port object to initialize and start processing</p></div>
<div class="paragraph"><p>This event is handled in code lines 380-432 in ieee1588port.cpp [called
from daemon]
* FAULT_DETECTED</p></div>
<div class="paragraph"><p>This event is handled in code lines 863-865 in ieee1588port.cpp
* QUALIFICATION_TIMEOUT_EXPIRES (unused)</p></div>
</li>
</ul></div>
<div class="paragraph"><p>addEventTimer()/addEventTimerLocked() – add event timer and locks the
underlying OSTimerQueue object in locked version of the call [more
explanation, why]</p></div>
<div class="paragraph"><p>deleteEventTimer()/deleteEventTimerLocked() – delete event timer and
locks the underlying OSTimerQueue object in locked version of the call</p></div>
</div>
<div class="sect3">
<h4 id="selected-methods">Selected Methods</h4>
<div class="paragraph"><p><em>setMasterOffset</em> – this function updates the frequency and phase
offsets between the 802.1AS grandmaster and the local network device
clock and between the system (e.g. gettimeofday) and local network
clock.[what is this used for?]</p></div>
<div class="paragraph"><p>This function is called from ptp_message.cpp (code line 1001) when the
port is in PTP_SLAVE mode and followup message is received. It is also
called from ieee1588port.cpp (code line 816) when the port is in
PTP_MASTER mode.</p></div>
<div class="paragraph"><p><em>serializeState</em> – this function writes out several clock parameters to
char buffer. This may be used to cache state for faster startup.</p></div>
<div class="paragraph"><p>The parameters currently cached are: Local device to GM clock offsets,
Local device to System clock offset, GM Identity</p></div>
<div class="paragraph"><p><em>restoreSerializedState</em> – this function reads clock parameters that
were previously written out by a call to serializeState</p></div>
</div>
</div>
<div class="sect2">
<h3 id="port-ieee1588port-class-in-avbts_port.hppieei1588port.cpp">Port (IEEE1588Port class in avbts_port.hpp/ieei1588port.cpp)</h3>
<div class="paragraph"><p>The IEEE1588Port class is a container for per-port state and methods</p></div>
<div class="sect3">
<h4 id="initialization">Initialization</h4>
<div class="paragraph"><p>Initialization of port state is done in the constructor. Much of the
state corresponds closely with the MDPort entity in [1]. The rest of the
initialization, including initializing the OS/device specific
timestamper (HWTimestamper derived object) and network device
(OSNetworkInterface derived object) is completed in init_port which is
called in main. The initialization operation is split in two functions
to accommodate future implementations that require additional OS/device
specific initialization in between. Initialization and the port
operations is started when the POWERUP/INITIALIZE event is received. The
openPort method is started in another thread. This thread processes
incoming messages.</p></div>
</div>
<div class="sect3">
<h4 id="selected-methods-1">Selected Methods</h4>
<div class="paragraph"><p><em>openPort</em> – receives incoming messages and associated timestamps in
while loop. Triggers processing of those messages.</p></div>
<div class="paragraph"><p><em>processEvent</em> – processes events received by the port. See section I.a
of this document for message types and associated actions</p></div>
<div class="paragraph"><p><em>serializeState</em> – this function writes out several port parameters to
char buffer. This may be used to cache state for faster startup</p></div>
<div class="paragraph"><p><em>restoreSerializedState</em> – this function reads port parameters that were
previously written out by a call to serializeState</p></div>
</div>
</div>
<div class="sect2">
<h3 id="message">Message</h3>
<div class="paragraph"><p>ptp_message.cpp</p></div>
<div class="sect3">
<h4 id="class-ptpmessagecommon">class PTPMessageCommon</h4>
<div class="paragraph"><p>All message types derive from this class. The common methods are:</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>processMessage</em> – this code processes a message after it is received
</p>
</li>
<li>
<p>
<em>sendPort</em> – this code transmits a message
</p>
</li>
</ul></div>
</div>
<div class="sect3">
<h4 id="derived-message-typesclasses">Derived Message Types/Classes</h4>
<div class="ulist"><ul>
<li>
<p>
PTPMessageSync – represents sync message
</p>
</li>
<li>
<p>
PTPMessageFollowUp – followup message
</p>
</li>
<li>
<p>
PTPMessagePathDelayReq – pdelay request
</p>
</li>
<li>
<p>
PTPMessagePathDelayResp – pdelay response
</p>
</li>
<li>
<p>
PTPMessagePathDelayRespFollowUp – pdelay response followup
</p>
</li>
</ul></div>
</div>
<div class="sect3">
<h4 id="selected-methods-2">Selected Methods</h4>
<div class="paragraph"><p><em>buildPTPMessage</em> – when a message buffer is received, this function is
called to parse it. The return value is an object representing the
message or NULL if parsing fails</p></div>
<div class="paragraph"><p><em>buildCommonHeader</em> – this function writes the common header information
(see [1] clause 10.5.2 and clause 11.4.2) to a buffer for transmission</p></div>
<div class="paragraph"><p><em>PTPMessageAnnounce::isBetterThan</em> – this function compares this object
with that of the argument and returns true if this is better (see
discussion of systemIdentity in [1] clause 10.3.2)</p></div>
</div>
<div class="sect3">
<h4 id="sync-transmission-ptp_master-mode">Sync Transmission (PTP_MASTER mode)</h4>
<div class="paragraph"><p>When the SYNC_INTERVAL_TIMEOUT_EXPIRES event (see section I.a of this
document) is received by the port a new PTPMessageSync object is
initialized and transmitted. The transmit timestamp is read from the
timestamper object. A PTPMessageFollowUp object is initialized and the
timestamp is added to the object and transmitted.</p></div>
<div class="paragraph"><p><span class="image">
<img src="https://raw.githubusercontent.com/AVnu/OpenAvnu/gh-pages/images/ptp/Sync%20Transmission%20%28PTP_MASTER%20mode%29.PNG"/>
</span>
<strong>Figure 1. Sync Transmission (PTP_MASTER mode) Sequence Diagram</strong></p></div>
</div>
<div class="sect3">
<h4 id="sync-reception-ptp_slave-mode">Sync Reception (PTP_SLAVE mode)</h4>
<div class="paragraph"><p>When a message of type PTPMessageSync is received it is saved along with
the receive timestamp until either a corresponding message of type
PTPMessageFollowUp (followup) is received or another sync message is
received. When a followup message is received
PTPMessageFollowup::processMessage is executed. The saved sync
information is retrieved and checked. The preciseOriginTimestamp
(remote) is used with the sync timestamp (local) to compute the offset
between the local device clock and the GM clock and calls
IEEE1588Clock::setMasterOffset. Reception of a valid sync and followup
restarts the SYNC_RECEIPT_TIMEOUT timer on the corresponding port
object.</p></div>
<div class="paragraph"><p><span class="image">
<img src="https://raw.githubusercontent.com/AVnu/OpenAvnu/gh-pages/images/ptp/Sync%20Reception%20%28PTP_SLAVE%20mode%29.PNG"/>
</span>
<strong>Figure 2. Sync Reception (PTP_SLAVE mode) Sequence Diagram</strong></p></div>
</div>
<div class="sect3">
<h4 id="pdelay-transmission">Pdelay Transmission</h4>
<div class="paragraph"><p>When the PDELAY_INTERVAL_TIMEOUT_EXPIRES event (see section I.a of this
document) is received by the port a new PTPMessagePathDelayReq object is
initialized and transmitted. The transmit timestamp is read (T1) from
the timestamper object. The request is stored until a response
(PTPMessagePathDelayResp) and response followup
(PTPMessagePathDelayRespFollowUp) is received. The receive timestamp
from the response is captured (T4). The pdelay response and pdelay
response followup messages contain remote timestamps for reception of
the request (T2) and transmission of the response (T3). The link delay
is calculated:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>LD = ((T4-T1)-(T3-T2))/2</code></pre>
</div></div>
<div class="paragraph"><p>The link delay in the Sync Reception operation.</p></div>
<div class="paragraph"><p><span class="image">
<img src="https://raw.githubusercontent.com/AVnu/OpenAvnu/gh-pages/images/ptp/Pdelay%20Transmission.PNG"/>
</span>
<strong>Figure 3. PDelay Transmission Sequence Diagram</strong></p></div>
</div>
<div class="sect3">
<h4 id="pdelay-reception">PDelay Reception</h4>
<div class="paragraph"><p>When a message of type PTPMessagePathDelayReq is received a response
(PTPMessagePathDelayResponse) is initialized, populated with the request
receive timestamp, and transmitted. A response followup
(PTPMessagePathDelayRespFollowUp) is initialized, populated with the
response transmit timestamp, and transmitted.</p></div>
<div class="paragraph"><p><span class="image">
<img src="https://raw.githubusercontent.com/AVnu/OpenAvnu/gh-pages/images/ptp/Pdelay%20Reception.PNG"/>
</span>
<strong>Figure 4. PDelay Reception Sequence Diagram</strong></p></div>
</div>
</div>
<div class="sect2">
<h3 id="os-abstractions">OS Abstractions</h3>
<div class="paragraph"><p>The OS abstractions are interface definitions where OS specific
implementations are provided in the Linux and Windows directories
providing common OS services (e.g. locking, networking)</p></div>
<div class="ulist"><ul>
<li>
<p>
OSCondition (avbts_oscondition.hpp) – condition variable abstraction
</p>
</li>
<li>
<p>
OSNetworkInterface (avbts_osnet.hpp) – network interface abstraction, provides and receive operations
</p>
</li>
<li>
<p>
OSTimerQueue (avbts_ostimerq.hpp) – timer queue interface that allows scheduling of multiple events used for add/delete timer methods in the clock class
</p>
</li>
<li>
<p>
OSTimer (avbts_ostimer.hpp) – timer abstraction providing sleep method that is approximately millisecond accurate
</p>
</li>
<li>
<p>
OSThread (avbts_osthread.hpp) – thread abstraction
</p>
</li>
<li>
<p>
OSLock (avbts_oslock.hpp) – lock abstraction
</p>
</li>
<li>
<p>
HWTimestamper (ieee1588.hpp) – timestamper abstraction providing methods for retrieving transmit and receive timestamps and cross timestamps between the network device clock and the system clock
</p>
</li>
<li>
<p>
OS_IPC (avbts_osipc.hpp) – IPC abstraction used to communicate calculated offsets to other application
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="pdelay-flow-control">PDelay Flow Control</h3>
<div class="sect3">
<h4 id="pdelay-transmission-1">PDelay Transmission</h4>
<div class="paragraph"><p><strong>Initialization:</strong> The Pdelay transaction is initiated in
ieee1588port.cpp by calling IEEE1588Port::startPDelay() from the handler
code for the POWERUP/INITIALIZE port event (located in
IEEE1588::processEvent()). This event is sent from the main() function
in daemon_cl.cpp. The startPDelay() function adds an event of type
PDELAY_INTERVAL_TIMEOUT_EXPIRES by calling
IEEE1588Clock::addEventTimer().</p></div>
<div class="paragraph"><p><strong>Transmit Request:</strong> When that event is delivered it is, again, handled
in IEEE1588Port::processEvent(). The PDELAY_INTERVAL_TIMEOUT_EXPIRES
handler code builds a Pdelay message, setting the timestamp to
PDELAY_PENDING_TIMESTAMP, saving the message by calling
IEEE1588Port::setLastPDelayReq(), and transmits the message calling
PTPMessagePathDelayReq ::sendPort(). After transmission is complete, the
pending timestamp is replaced with a valid timestamp. When this
completes a PDELAY_INTERVAL_TIMEOUT_EXPIRES event is requested at the
next Pdelay interval by calling IEEE1588Clock::addEventTimer().</p></div>
<div class="paragraph"><p><strong>Receive Response:</strong> The packet receive loop is in
IEEE1588Port::openPort. This code runs in a second thread. Processing of
the PTP message begins in buildPTPMessage(). If parsing is successful,
the processMessage() method is called. For Pdelay responses
PTPMessagePathDelayResp::processMessage() is called for message specific
processing. There isn’t any processing done until the response follow-up
message is received. The Pdelay response and corresponding timestamp is
saved by calling IEEE1588Port::setLastPDelayResp(). When, the Pdelay
response followup is received, the same sequence of calls takes place
with PTPMessagePathDelayRespFollowup::processMessage() being called for
message specific processing. Processing for Pdelay response follow-up
messages validates several message elements (e.g. sequence id, source
identity) and calculates the offset from the peer device. If during
processing a timestamp set to PDELAY_PENDING_TIMESTAMP is encountered,
processing is delayed by scheduling an event of type
PDELAY_DEFERRED_PROCESSING is scheduled. This occurs in the case that
the response from the peer is received before the timestamp is received
from the driver. This is possible because the receive loop runs in its
own thread. That event is handled in IEEE1588::processEvent() and causes
processing to be periodically retried until it is complete.</p></div>
<div class="paragraph"><p><strong>Transmit Response:</strong> When a Pdelay request is received processing flows
as above. The message specific processing occurs in
PTPMessagePathDelayReq::processMessage(). A response frame is
constructed containing the receive timestamp corresponding to the
request. The message is transmitted calling
PTPMessagePathDelayResp::sendPort(). A response follow-up is constructed
containing the transmit timestamp corresponding to the response message
and is transmitted.</p></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="linux-code">Linux Code</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="common-linux_hal_common.hpp-linux_hal_common.cpp">Common (linux_hal_common.hpp/ linux_hal_common.cpp)</h3>
<div class="paragraph"><p>Contains:</p></div>
<div class="ulist"><ul>
<li>
<p>
Linux specific network interface (LinuxNetworkInterface)
</p>
</li>
<li>
<p>
Pthread locks (mutex) (LinuxLock)
</p>
</li>
<li>
<p>
Pthread condition (LinuxCondition)
</p>
</li>
<li>
<p>
Timer (LinuxTimer)
</p>
</li>
<li>
<p>
TimerQueue (LinuxTimerQueue)
</p>
</li>
<li>
<p>
Pthread abstraction (LinuxThread)
</p>
</li>
<li>
<p>
Shared memory IPC (LinuxSharedMemoryIPC) – Offsets are made available
to other processes via shared memory
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="generic-linux_hal_generic.hpplinux_hal_generic.cpplinux_hal_generic_adj.cpp">Generic</h3>
<div class="paragraph"><p>(linux_hal_generic.hpp/linux_hal_generic.cpp/linux_hal_generic_adj.cpp)</p></div>
<div class="paragraph"><p>Contains:</p></div>
<div class="ulist"><ul>
<li>
<p>
Generic Linux timestamp code (LinuxTimestamperGeneric)
</p>
</li>
</ul></div>
<div class="paragraph"><p>Note: The clock adjustment code in linux_hal_generic_adj.cpp is in a
separate file due to multiple definitions of time related structs</p></div>
</div>
<div class="sect2">
<h3 id="i210-linux_hal_i210.cpp">I210 (linux_hal_i210.cpp)</h3>
<div class="paragraph"><p>Contains:</p></div>
<div class="ulist"><ul>
<li>
<p>
Pulse per second code specific to I210
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="intelce">IntelCE</h3>
<div class="paragraph"><p>Contains:</p></div>
<div class="ulist"><ul>
<li>
<p>
IntelCE specific timestamp code (LinuxTimestamperIntelCE)
</p>
</li>
</ul></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="windows-windows_hal.cppwindows_hal.hpp">Windows (windows_hal.cpp/windows_hal.hpp)</h2>
<div class="sectionbody">
<div class="paragraph"><p>Contains:</p></div>
<div class="ulist"><ul>
<li>
<p>
Windows specific network interface (WindowsPCAPNetworkInterface) using
PCAP for layer 2 frame transmission and reception
</p>
</li>
<li>
<p>
Windows locks (mutex) (WindowsLock)
</p>
</li>
<li>
<p>
WIndows condition variable (WindowsCondition)
</p>
</li>
<li>
<p>
Timer (WindowsTimer)
</p>
</li>
<li>
<p>
Windows TimerQueue (WindowsTimerQueue)
</p>
</li>
<li>
<p>
Windows thread abstraction (WindowsThread)
</p>
</li>
<li>
<p>
Named pipe IPC (WIndowsNamedPipeIPC) – Offsets are made available to
other processes named pipe transactions
</p>
</li>
<li>
<p>
Windows/Intel specific timestamp code (WindowsTimestamper)
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="tbd">TBD</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
Add IPC interface description
</p>
</li>
<li>
<p>
Add directory structure description
</p>
</li>
<li>
<p>
Add discussion of IntelCE auxiliary clock
</p>
</li>
</ul></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2018-07-19 15:37:52 CST
</div>
</div>
</body>
</html>
